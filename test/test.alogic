
const u8 cheese = 4;

import "cheese";
import "cheese" as cake;
import "cheese/fromage" as cabbage;

from "cake" import cheese;
from "cake/cheese" import something;
from "cake/cheese" import something as bread;

struct intra_angle_est_bin_map_weight_output_t {
  bool use128;
  u22 allowed_sizes; // for luma/chroma as required
  num_cands_t num_cands; // for luma/chroma as required
  bool chroma;
  gen for (uint p < GRAD_PARALLEL) {
    hist_bucket_idx_t bucket_idx#[p];
    hist_bin_idx_t bin_idx#[p]; // test comment
    grad_weight_t weight#[p];
  }
}

typedef u3 angle_delta_unsigned_t;
struct angle_delta_funcs {
  /* Function to map an unsigned delta (bin index within a bucket) to the
  absolute value of the signed delta this represents. */
  static u2 unsigned_to_abs_signed(angle_delta_unsigned_t d) {
    u2 output;
    case (d) {
      3'd0, 3'd6: output = 2'd3;
      3'd1, 3'd5: output = 2'd2;
      3'd2, 3'd4: output = 2'd1;
      default: {
        assert d == 3'd3;
        output = 2'd0;
        break;
      }
    }
    return output;
  }
}

fsm cake
{
  // Comment
  param uint UNSIZED_BINARY = 'b01;
  param uint SIZED_BINARY = 8'b01;
  param uint UNSIZED_HEX = 'h0123456789aBcDeF;
  param uint SIZED_HEX = 8'h0123456789aBcDeF; // Comment
  param uint UNSIZED_DEC = 'd0123456789;
  param uint SIZED_DEC = 8'd0123456789;
  param uint UNSPECIFIED_PARAM;
  const uint FREE_NUMBER = 12345;
  const string FREE_STRING = "string";
  const thing_t other = cheese;

  in the hood;
  in sync cake_t cake;
  in sync ready cake_t cake;
  in sync accept cake_t cake;
  in sync greedy cake_t cake;

  out the hood;
  out sync cake_t cake;
  out sync ready cake_t cake;
  out sync accept cake_t cake;
  out sync greedy cake_t cake;

  uint fun_times = 19;

  gen if (a + (b + c)) {
    out sync ready u9 fun;
  }

  gen for (uint X = 0; X < cake; cake++) {
    in wire porty_mc_port_face#[X];
  }

  gen for (uint P < 8) {
    in wire porty_mc_port_face#[P];
  }

  /* A long comment */
  void main()
  {
    u32 a;
    u32 b = 1;
    a = 1;
    fun_t badger = cake.read();
    if (badger) {
      salmon.write(1);
    } else if (a) {
      salmon.write(2);
    } else {
      salmon.write(3);
    }

    gen if (a + (b + c)) {
      u8 a = (1 + 2);
    }

    gen for (uint X = 0; X < cake; cake++) {
      u8 a = (1 + 2);
    }

    gen for (uint P < 8) {
      u8 a = (1 + 2);
    }

    cheese.write(badger);
    while (cheese) {
      u8 cake = jam + sponge - butter_cream;
      u17 plam = |((cake && cheese) > &badger[12+:4]) - 'hAA;
    }

    loop {
      break;
    }

    case (quack) {
      12: {

      }
    }
    // What are the things that go here?
    fence;
  }

  fence
  {
    cheese = 1'b0;
  }

  fence {

  }

  // These shouldn't highlight

  new fsm singleton {

  }

  cake = new cake();

  in -> cake.in;
}

network net {
  in sync ready port_t port;
  out           bool   cake;

  param uint CHEESE = 1'h7;
  const i32 VALUE = 9;

  gen if (a + (b + c)) {
    out sync ready u9 fun;
  }

  gen for (uint X = 0; X < cake; cake++) {
    in wire porty_mc_port_face;
  }

  gen for (uint P < 8) {
    in wire porty_mc_port_face;
  }

  new fsm singleton {

  }

  cake = new cake();

  in -> cake.in;

  // These shouldn't highlight

  uint val;
  uint value = 4;

  void main() {

  }

  fence {

  }
}

verbatim entity arb {
  in  sync ready u8 i_0;
  in  sync ready u8 i_1;
  out sync ready u8 o;

  verbatim verilog {
    // i_0 has priority
    assign o = i_0__valid ? i_0 : i_1;
    assign o__valid = i_0__valid | i_1__valid;
    assign i_0__ready = o__ready;
    assign i_1__ready = o__ready & ~i_0__valid;
  }
}

// These shouldn't highlight

param u10 a_name = 7;
